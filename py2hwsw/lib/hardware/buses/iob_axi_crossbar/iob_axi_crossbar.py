# SPDX-FileCopyrightText: 2024 IObundle
#
# SPDX-License-Identifier: MIT

import sys
import os

# Add crossbar scripts folder to python path
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "scripts"))

from iob_axi_crossbar_wrap import generate


def setup(py_params_dict):
    """AXI nonblocking crossbar interconnect with parametrizable data and address interface widths and master and slave interface counts. Supports all burst types. Fully nonblocking with completely separate read and write paths; ID-based transaction ordering protection logic; and per-port address decode, admission control, and decode error handling. Wrapper for axi_crossbar_rd and axi_crossbar_wr."""

    params = {
        # Name of generated module
        "name": None,
        # Number of master to connect (= number of slave interfaces)
        "num_masters": 1,
        # Number of slaves to connect (= number of master interfaces)
        "num_slaves": 1,
        # Build directory (usually auto-filled py py2hwsw).
        "build_dir": "",
        # Destination directory inside build directory.
        "dest_dir": "hardware/src",
    }

    # Update params with values from py_params_dict
    for param in py_params_dict:
        if param in params:
            params[param] = py_params_dict[param]

    # Each generated interconnect must have a unique name (can't have two verilog modules with same name).
    assert params["name"], print(
        "Error: Missing name for generated axi crossbar module."
    )

    m = params["num_masters"]
    n = params["num_slaves"]

    # Don't generate files for other py2 targets (like clean)
    if py_params_dict.get("py2hwsw_target", "") == "setup":
        # Generate crossbar verilog source
        generate(
            ports=(m, n),
            name=params["name"],
            output=os.path.join(
                params["build_dir"], params["dest_dir"], params["name"] + ".v"
            ),
        )

    # Verilog paramters matching the ones generated by `iob_axi_crossbar_wrap.py`
    axi_verilog_params = [
        ("DATA_WIDTH", 32, "Width of data bus in bits"),
        ("ADDR_WIDTH", 32, "Width of address bus in bits"),
        (
            "STRB_WIDTH",
            "(DATA_WIDTH/8)",
            "Width of wstrb (width of data bus in words)",
        ),
        ("S_ID_WIDTH", 8, "Input ID field width (from AXI masters)"),
        (
            "M_ID_WIDTH",
            "S_ID_WIDTH+$clog2(S_COUNT)",
            "Output ID field width (towards AXI slaves)",
        ),
        ("AWUSER_ENABLE", 0, "Propagate awuser signal"),
        ("AWUSER_WIDTH", 1, "Width of awuser signal"),
        ("WUSER_ENABLE", 0, "Propagate wuser signal"),
        ("WUSER_WIDTH", 1, "Width of wuser signal"),
        ("BUSER_ENABLE", 0, "Propagate buser signal"),
        ("BUSER_WIDTH", 1, "Width of buser signal"),
        ("ARUSER_ENABLE", 0, "Propagate aruser signal"),
        ("ARUSER_WIDTH", 1, "Width of aruser signal"),
        ("RUSER_ENABLE", 0, "Propagate ruser signal"),
        ("RUSER_WIDTH", 1, "Width of ruser signal"),
        ("M_REGIONS", 1, "Number of regions per master interface"),
    ]
    for p in range(m):
        axi_verilog_params += [
            (f"S{p:02d}_THREADS", 2, "Number of concurrent unique IDs"),
            (f"S{p:02d}_ACCEPT", 16, "Number of concurrent operations"),
        ]
    for p in range(n):
        axi_verilog_params += [
            (
                f"M{p:02d}_BASE_ADDR",
                0,
                "Master interface base addresses. M_REGIONS concatenated fields of ADDR_WIDTH bits",
            ),
            (
                f"M{p:02d}_ADDR_WIDTH",
                "{M_REGIONS{32'd24}}",
                "Master interface address widths. M_REGIONS concatenated fields of 32 bits",
            ),
            (
                f"M{p:02d}_CONNECT_READ",
                f"{m}'b" + "".join("1" for _ in range(m)),
                "Read connections between interfaces. S_COUNT bits",
            ),
            (
                f"M{p:02d}_CONNECT_WRITE",
                f"{m}'b" + "".join("1" for _ in range(m)),
                "Write connections between interfaces. S_COUNT bits",
            ),
            (
                f"M{p:02d}_ISSUE",
                4,
                "Number of concurrent operations for each master interface",
            ),
            (
                f"M{p:02d}_SECURE",
                0,
                "Secure master (fail operations based on awprot/arprot)",
            ),
        ]
    for p in range(m):
        axi_verilog_params += [
            (
                f"S{p:02d}_AW_REG_TYPE",
                0,
                "Slave interface AW channel register type (input). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
            (
                f"S{p:02d}_W_REG_TYPE",
                0,
                "Slave interface W channel register type (input). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
            (
                f"S{p:02d}_B_REG_TYPE",
                1,
                "Slave interface B channel register type (output). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
            (
                f"S{p:02d}_AR_REG_TYPE",
                0,
                "Slave interface AR channel register type (input). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
            (
                f"S{p:02d}_R_REG_TYPE",
                2,
                "Slave interface R channel register type (output). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
        ]
    for p in range(n):
        axi_verilog_params += [
            (
                f"M{p:02d}_AW_REG_TYPE",
                1,
                "Master interface AW channel register type (output). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
            (
                f"M{p:02d}_W_REG_TYPE",
                2,
                "Master interface W channel register type (output). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
            (
                f"M{p:02d}_B_REG_TYPE",
                0,
                "Master interface B channel register type (input). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
            (
                f"M{p:02d}_AR_REG_TYPE",
                1,
                "Master interface AR channel register type (output). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
            (
                f"M{p:02d}_R_REG_TYPE",
                0,
                "Master interface R channel register type (input). 0 to bypass, 1 for simple buffer, 2 for skid buffer",
            ),
        ]

    attributes_dict = {
        "name": params["name"],
        "generate_hw": False,
        "version": "0.1",
    }
    #
    # Confs
    #
    attributes_dict["confs"] = []
    for param, default_val, description in axi_verilog_params:
        attributes_dict["confs"].append(
            {
                "name": param,
                "type": "P",
                "val": default_val,
                "min": "NA",
                "max": "NA",
                "descr": description,
            }
        )
    #
    # Ports
    #
    attributes_dict["ports"] = [
        {
            "name": "clk_i",
            "descr": "Clock",
            "signals": [
                {
                    "name": "clk_i",
                    "width": 1,
                },
            ],
        },
        {
            "name": "rst_i",
            "descr": "Synchronous reset",
            "signals": [
                {
                    "name": "rst_i",
                    "width": 1,
                },
            ],
        },
    ]
    for p in range(n):
        attributes_dict["ports"].append(
            {
                "name": f"m{p}_axi_m",
                "descr": f"Master interface {p}",
                "signals": {
                    "type": "axi",
                    "prefix": f"m{p:02d}_",
                    "ID_W": "M_ID_WIDTH",
                    "ADDR_W": "ADDR_WIDTH",
                    "LEN_W": 8,
                    "LOCK_W": 1,
                    "DATA_W": "DATA_WIDTH",
                },
            }
        )
    for p in range(m):
        attributes_dict["ports"].append(
            {
                "name": f"s{p}_axi_s",
                "descr": f"Slave interface {p}",
                "signals": {
                    "type": "axi",
                    "prefix": f"s{p:02d}_",
                    "ID_W": "S_ID_WIDTH",
                    "ADDR_W": "ADDR_WIDTH",
                    "LEN_W": 8,
                    "LOCK_W": 1,
                    "DATA_W": "DATA_WIDTH",
                },
            }
        )

    attributes_dict["subblocks"] = [
        {
            "core_name": "iob_arbiter",
        },
    ]

    return attributes_dict
