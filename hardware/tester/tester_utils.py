#!/usr/bin/env python3
# It has functions to auto generate a template portmap based on peripherals list
# It's also used to read the portmap file, verify its correctness and generate tester.v that includes the SUT instance 

import sys
import subprocess
import os
import re

# Add folder to path that contains python scripts to be imported
sys.path.append(os.path.join(os.path.dirname(__file__), '../../software'))
import submodule_utils 
from submodule_utils import *

# Header to be put in portmap config file
portmap_header = """\
//********************************************************************************************************************************
// Use this file to configure port mapping between the Tester peripherals, SUT peripherals and external interface of the Tester.
// This file was auto-generated by the 'make tester-config' target (portmap.py)
// Port map syntax:
//    Tester.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : External
//    SUT.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : External
//    Tester.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : SUT.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name>
//      or
//    SUT.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : Tester.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name>
// Example, to connect UART instance number 1 of SUT to UART instance number 0 of Tester:
//    Tester.UART[0].UART_txd : SUT.UART[1].UART_rxd
//    Tester.UART[0].UART_rxd : SUT.UART[1].UART_txd
//    Tester.UART[0].UART_rts : SUT.UART[1].UART_cts
//    Tester.UART[0].UART_cts : SUT.UART[1].UART_rts
// Example, to connect UART instance number 0 of SUT to a dedicated external interface of the tester: 
//    SUT.UART[0].UART_rxd : External
//    SUT.UART[0].UART_txd : External
//    SUT.UART[0].UART_cts : External
//    SUT.UART[0].UART_rts : External
//********************************************************************************************************************************
// Auto-generated list of signals to be mapped (by default mapped to external interface):
"""

# SUT instance to be included in tester
sut_instance_template = """\
system sut (
    //SUTPORTS

`ifdef USE_DDR
    //address write
    .m_axi_awid    (m_axi_awid[0]),
    .m_axi_awaddr  (m_axi_awaddr[0]),
    .m_axi_awlen   (m_axi_awlen[0]),
    .m_axi_awsize  (m_axi_awsize[0]),
    .m_axi_awburst (m_axi_awburst[0]),
    .m_axi_awlock  (m_axi_awlock[0]),
    .m_axi_awcache (m_axi_awcache[0]),
    .m_axi_awprot  (m_axi_awprot[0]),
    .m_axi_awqos   (m_axi_awqos[0]),
    .m_axi_awvalid (m_axi_awvalid[0]),
    .m_axi_awready (m_axi_awready[0]),

    //write  
    .m_axi_wdata   (m_axi_wdata[0]),
    .m_axi_wstrb   (m_axi_wstrb[0]),
    .m_axi_wlast   (m_axi_wlast[0]),
    .m_axi_wvalid  (m_axi_wvalid[0]),
    .m_axi_wready  (m_axi_wready[0]),

    //write response
    .m_axi_bid     (m_axi_bid[0]),
    .m_axi_bresp   (m_axi_bresp[0]),
    .m_axi_bvalid  (m_axi_bvalid[0]),
    .m_axi_bready  (m_axi_bready[0]),

    //address read
    .m_axi_arid    (m_axi_arid[0]),
    .m_axi_araddr  (m_axi_araddr[0]),
    .m_axi_arlen   (m_axi_arlen[0]),
    .m_axi_arsize  (m_axi_arsize[0]),
    .m_axi_arburst (m_axi_arburst[0]),
    .m_axi_arlock  (m_axi_arlock[0]),
    .m_axi_arcache (m_axi_arcache[0]),
    .m_axi_arprot  (m_axi_arprot[0]),
    .m_axi_arqos   (m_axi_arqos[0]),
    .m_axi_arvalid (m_axi_arvalid[0]),
    .m_axi_arready (m_axi_arready[0]),

    //read   
    .m_axi_rid     (m_axi_rid[0]),
    .m_axi_rdata   (m_axi_rdata[0]),
    .m_axi_rresp   (m_axi_rresp[0]),
    .m_axi_rlast   (m_axi_rlast[0]),
    .m_axi_rvalid  (m_axi_rvalid[0]),
    .m_axi_rready  (m_axi_rready[0]),	
`endif               
    .clk           (clk),
    .reset         (reset),
    .trap          (trap[0])
    );
"""

# Returns dictionary with amount of instances each peripheral of the Tester to be created 
def get_tester_peripherals():
    tester_peripherals = subprocess.run(['make', '--no-print-directory', '-C', root_dir+'/hardware/tester', 'tester-peripherals', 'SUT_DIR=../..', 'TESTER_ENABLED=1'], stdout=subprocess.PIPE)
    tester_peripherals = tester_peripherals.stdout.decode('ascii').split()

    tester_instances_amount = {}
    for i in tester_peripherals:
        tester_instances_amount[i]=tester_peripherals.count(i)

    return tester_instances_amount


# Overwrites portmap configuration file with a template, with every existing signal mapped to external interface by default
def generate_portmap():
    sut_instances_amount = get_sut_peripherals()
    tester_instances_amount = get_tester_peripherals()
    submodule_directories = get_submodule_directories()
    peripheral_signals = get_peripherals_signals({**sut_instances_amount, **tester_instances_amount},submodule_directories)

    # Generate portmap file
    portmap_file = open(root_dir+"/hardware/tester/peripheral_portmap.txt", "w")
    portmap_file.write(portmap_header)

    # Create signals for every peripheral instance
    for corename in sut_instances_amount:
        for i in range(sut_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signal = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                portmap_file.write("SUT.{}[{}].{} : External\n".format(corename,i,signal))
    portmap_file.write("//Tester peripheral signals (you can remove some of these signals and map them to the SUT signals above instead)\n")
    for corename in tester_instances_amount:
        for i in range(tester_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signal = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                portmap_file.write("Tester.{}[{}].{} : External\n".format(corename,i,signal))
    portmap_file.close()

# Reads portmap file
# Returns:
#    pwires: List of signals that will interconnect SUT with Tester peripherals
#    mapped_signals: Dimensions=[<0 for SUT; 1 for Tester>][<corename>][<instance number>][<signal name with macro>]
#                    This list of dictionaries stores the -2 for unmapped signals, -1 for mapped to external interface 
#                    and >0 for signals mapped to a wire in pwires list with that index.
def read_portmap(sut_instances_amount, tester_instances_amount, peripheral_signals):
    # Wires internal to Tester that interface SUT and Tester peripherals
    pwires = []
    # Array to store if a signal has been mapped
    # -2 not mapped, -1 mapped to external interface, 0< mapped to signal in pwires (index)
    mapped_signals = [{},{}] # SUT signals and Tester Signals
    for corename in sut_instances_amount:
        mapped_signals[0][corename] = []
        for i in range(sut_instances_amount[corename]):
            mapped_signals[0][corename].append({})
            for signal in peripheral_signals[corename]:
                signal = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                mapped_signals[0][corename][i][signal] = -2
    for corename in tester_instances_amount:
        mapped_signals[1][corename] = []
        for i in range(tester_instances_amount[corename]):
            mapped_signals[1][corename].append({})
            for signal in peripheral_signals[corename]:
                signal = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                mapped_signals[1][corename][i][signal] = -2

    # Read portmap file
    portmap_file = open(root_dir+"/hardware/tester/peripheral_portmap.txt", "r")
    portmap_contents = portmap_file.readlines() 
    portmap_file.close()

    # Parse signals, map them and create pwires signals
    for idx, i in enumerate(portmap_contents):
        if not i.startswith("//"):
            i=i.replace(" ", "") # Remove all spaces
            result = re.search("^([^\.]+)\.([^\[]+)\[(\d+)\]\.([^\:]+)\:(?:(?:External)|(?:([^\.\n]+)\.([^\[]+)\[(\d+)\]\.(.+)))$", i)
            if result is not None:
                try:
                    # Make sure it has not been mapped before
                    if mapped_signals[0 if result.group(1)=="SUT" else 1][result.group(2)][int(result.group(3))][result.group(4)] < -1:
                        if result.group(5) is None: # Mapped to external interface
                                mapped_signals[0 if result.group(1)=="SUT" else 1][result.group(2)][int(result.group(3))][result.group(4)] = -1
                        else: # Mapped between SUT and Tester
                            if result.group(1) != result.group(5): # Make sure we are not mapping SUT or Tester with itself 
                                # Make sure it has not been mapped before
                                if mapped_signals[0 if result.group(5)=="SUT" else 1][result.group(6)][int(result.group(7))][result.group(8)] < -1:
                                    # Get signal with macro
                                    signalWithMacro = [result.group(4).replace(result.group(2),"/*<InstanceName>*/"),result.group(8).replace(result.group(6),"/*<InstanceName>*/")]
                                    # Make sure we are connecting an input and an output
                                    if ("input" in peripheral_signals[result.group(2)][signalWithMacro[0]] and "output" in peripheral_signals[result.group(6)][signalWithMacro[1]]) or\
                                       ("output" in peripheral_signals[result.group(2)][signalWithMacro[0]] and "input" in peripheral_signals[result.group(6)][signalWithMacro[1]]):
                                        # Create pwires signal to merge them
                                        pwires.append("merge_{}_{}_{}_with_{}_{}_{}".format(result.group(1),result.group(4),result.group(3),result.group(5),result.group(8),result.group(7)))
                                        # Store index of pwires signal in mapping
                                        mapped_signals[0 if result.group(1)=="SUT" else 1][result.group(2)][int(result.group(3))][result.group(4)] = len(pwires)-1
                                        mapped_signals[0 if result.group(5)=="SUT" else 1][result.group(6)][int(result.group(7))][result.group(8)] = len(pwires)-1
                                    else:
                                        print("Error: Portmap file line {}, can't connect because both signals are of type {}!".format(idx+1,"input" if "input" in peripheral_signals[result.group(2)][signalWithMacro[0]] else "output"))
                                        exit(-1)
                                else:
                                    print("Error: Portmap file line {}, Signal {} of {}.{}[{}] already mapped previously!".format(idx+1,result.group(8),result.group(5),result.group(6),result.group(7)))
                                    exit(-1)
                            else:
                                print("Error: Portmap file line {}, can't map ports of {} with itself!".format(idx+1,result.group(1)))
                                exit(-1)
                    else:
                        print("Error: Portmap file line {}, Signal {} of {}.{}[{}] already mapped previously!".format(idx+1,result.group(4),result.group(1),result.group(2),result.group(3)))
                        exit(-1)
                except KeyError as e:
                    print("Error: Portmap file line {}, unknown parameter {}!".format(idx+1,e))
                    exit(-1)
                except IndexError as e:
                    print("Error: Portmap file line {}, could not find peripheral with index given!".format(idx+1))
                    exit(-1)
            else:
                print("Error parsing line {} of portmap file!".format(idx+1))
                exit(-1)

    #print(pwires) #DEBUG
    #print(mapped_signals) #DEBUG
    return pwires, mapped_signals

# Creates tester.v with SUT included 
def create_tester():
    # Get lists of peripherals and info about them
    sut_instances_amount = get_sut_peripherals()
    tester_instances_amount = get_tester_peripherals()
    submodule_directories = get_submodule_directories()
    peripheral_signals = get_peripherals_signals({**sut_instances_amount, **tester_instances_amount},submodule_directories)

    # Read portmap file and get encoded data
    pwires, mapped_signals = read_portmap(sut_instances_amount, tester_instances_amount, peripheral_signals)

    # Read template file
    tester_template_file = open(root_dir+"/hardware/src/system_core.v", "r") 
    tester_contents = tester_template_file.readlines() 
    tester_template_file.close()

    # Insert headers of peripherals of both systems
    for i in {**sut_instances_amount, **tester_instances_amount}:
        start_index = find_idx(tester_contents, "PHEADER")
        for file in os.listdir(root_dir+"/submodules/"+submodule_directories[i]+"/hardware/include"):
            if file.endswith(".vh"):
                tester_contents.insert(start_index, '`include "{}"\n'.format(root_dir+"/submodules/"+submodule_directories[i]+"/hardware/include/"+file))

    # Create PWIRES marker
    tester_contents.insert(find_idx(tester_contents, "endmodule")-1, '    //PWIRES\n')

    # Rename verilog module form 'system' to 'tester'
    tester_contents[find_idx(tester_contents, "module system")-1] = "module tester\n"

    # Add another trap signal for tester cpu
    tester_contents = [re.sub('output(\s+)trap', 'output [1:0]\g<1>trap', i) for i in tester_contents] 
    # Attach tester cpu to instance 0 of trap signal array
    tester_contents = [re.sub('\(trap\)', '(trap[1])', i) for i in tester_contents] 

    # Add another AXI bus for Tester memory
    tester_contents = [re.sub('((?:(?:output)|(?:input))\s+)((?:\[[^\]]+\])*\s+m_axi_[^,]+,)', '\g<1>[1:0]\g<2>', i) for i in tester_contents] 
    # Change Tester AXI interface to use instance 1 of AXI bus array
    tester_contents = [re.sub('(\(m_axi_[^\)]+)\)', '\g<1>[1])', i) for i in tester_contents] 

    # Insert SUT instance (includes SUTPORTS marker)
    start_index = find_idx(tester_contents, "endmodule")-1
    tester_contents = tester_contents[:start_index] + sut_instance_template.splitlines(True) + tester_contents[start_index:] 

    # Invert tester memory access bit
    #TODO: Check if this is correct
    tester_contents = [re.sub('.axi_awaddr\(m_axi_awaddr\[1\]\),', '.axi_awaddr({~m_axi_awaddr[1][`DDR_ADDR_W-1],m_axi_awaddr[1][`DDR_ADDR_W-2:0]}),', i) for i in tester_contents] 
    tester_contents = [re.sub('.axi_araddr\(m_axi_araddr\[1\]\),', '.axi_araddr({~m_axi_araddr[1][`DDR_ADDR_W-1],m_axi_araddr[1][`DDR_ADDR_W-2:0]}),', i) for i in tester_contents] 

    # Replace N_SLAVES by TESTER_N_SLAVES
    tester_contents = [re.sub('`N_SLAVES', '`TESTER_N_SLAVES', i) for i in tester_contents] 

    # Insert Tester peripherals
    for corename in tester_instances_amount:
        # Read inst.v file
        instv_file = open(root_dir+"/submodules/"+submodule_directories[corename]+"/hardware/include/inst.v", "r")
        instv_contents = instv_file.readlines() 
        # Insert for every instance
        for i in range(tester_instances_amount[corename]):
            # Insert peripheral instance
            start_index = find_idx(tester_contents, "endmodule")-1
            for j in reversed(instv_contents):
                # Check if this line contains a signal of PIO
                strMatch = re.search("\((\/\*<InstanceName>\*\/[^\)]+)\)",j)
                if strMatch and strMatch[1] in peripheral_signals[corename]:
                    # Line contains a pio.v signal, therefore change signal name to match PIO or PWIRES
                    signalModified = re.sub("\/\*<InstanceName>\*\/",corename,strMatch[1])
                    if mapped_signals[1][corename][i][signalModified] > -1: # Not mapped to external interface
                        # Signal is connected to corresponding pwires
                        tester_contents.insert(start_index, re.sub("\/\*<InstanceName>\*\/[^\)]+",pwires[mapped_signals[1][corename][i][signalModified]],j))
                    else: # Mapped to external interface
                        # Signal is connected to corresponding pio
                        tester_contents.insert(start_index, re.sub("\/\*<InstanceName>\*\/","tester_"+corename+str(i),j))
                else:
                    # Replace instace name verilog defines with tester defines (Because their values are different from SUT defines)
                    j = re.sub("`\/\*<InstanceName>\*\/","`TESTER_"+corename+str(i),j)
                    # Line did not contain any pio signal, so just insert it
                    # Also, replace instance name macros if their not verilog defines
                    tester_contents.insert(start_index, re.sub("\/\*<InstanceName>\*\/",corename+str(i),j))
        instv_file.close()

    # Array to store if pwires have been inserted
    pwires_inserted = [0] * len(pwires)
    # Insert PIO, PWIRES, SUTPORTS 
    for corename in sut_instances_amount:
        for i in range(sut_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signalModified = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                # Make sure this signal is mapped
                if mapped_signals[0][corename][i][signalModified] > -2:
                    if mapped_signals[0][corename][i][signalModified] > -1: # Not mapped to external interface
                        # Make sure we have not yet created PWIRE of this signal
                        if pwires_inserted[mapped_signals[0][corename][i][signalModified]] == False:
                            # Insert pwire
                            tester_contents.insert(find_idx(tester_contents, "PWIRES"), '    wire {};\n'.format(pwires[mapped_signals[0][corename][i][signalModified]]))
                            # Mark this signal as been inserted
                            pwires_inserted[mapped_signals[0][corename][i][signalModified]] = True
                        # Insert SUT PORT
                        tester_contents.insert(find_idx(tester_contents, "SUTPORTS"), '        .{}({}),\n'.format(re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal),pwires[mapped_signals[0][corename][i][signalModified]]))
                    else: # Mapped to external interface
                        # Insert PIO
                        tester_contents.insert(find_idx(tester_contents, "PIO"), '    {} sut_{},\n'.format(peripheral_signals[corename][signal],re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                        # Insert SUT PORT
                        tester_contents.insert(find_idx(tester_contents, "SUTPORTS"), '        .{}({}),\n'.format(re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal),"sut_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                else:
                    print("Error: signal {} of SUT.{}[{}] not mapped!".format(signal,corename,i))
                    exit(-1)
    for corename in tester_instances_amount:
        for i in range(tester_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signalModified = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                # Make sure this signal is mapped
                if mapped_signals[1][corename][i][signalModified] > -2:
                    if mapped_signals[1][corename][i][signalModified] > -1: # Not mapped to external interface
                        # Make sure we have not yet created PWIRE of this signal
                        if pwires_inserted[mapped_signals[1][corename][i][signalModified]] == False:
                            # Insert pwire
                            tester_contents.insert(find_idx(tester_contents, "PWIRES"), '    wire {};\n'.format(pwires[mapped_signals[1][corename][i][signalModified]]))
                            # Mark this signal as been inserted
                            pwires_inserted[mapped_signals[1][corename][i][signalModified]] = True
                        # Insert TESTER PORT #TODO: REMOVE THIS
                        #tester_contents.insert(find_idx(tester_contents, "TESTERPORTS"), '        .{}({}),\n'.format(re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal),pwires[mapped_signals[1][corename][i][signalModified]]))
                    else: # Mapped to external interface
                        # Insert PIO
                        tester_contents.insert(find_idx(tester_contents, "PIO"), '    {} tester_{},\n'.format(peripheral_signals[corename][signal],re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                        # Insert TESTER PORT #TODO: REMOVE THIS
                        #tester_contents.insert(find_idx(tester_contents, "TESTERPORTS"), '        .{}({}),\n'.format(re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal),"tester_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                else:
                    print("Error: signal {} of Tester.{}[{}] not mapped!".format(signal,corename,i))
                    exit(-1)



    # Write tester.v
    tester_file = open("tester.v", "w")
    tester_file.writelines(tester_contents)
    tester_file.close()

# Create testbench for simulation with the Tester
def create_testbench():
    # Get lists of peripherals and info about them
    sut_instances_amount = get_sut_peripherals()
    tester_instances_amount = get_tester_peripherals()
    submodule_directories = get_submodule_directories()
    peripheral_signals = get_peripherals_signals({**sut_instances_amount, **tester_instances_amount},submodule_directories)

    # Read portmap file and get encoded data
    pwires, mapped_signals = read_portmap(sut_instances_amount, tester_instances_amount, peripheral_signals)

    # Read template file
    testbench_template_file = open(root_dir+"/hardware/tester/tester_core_tb.v", "r") 
    testbench_contents = testbench_template_file.readlines() 
    testbench_template_file.close()

    # Insert headers of peripherals of both systems
    for i in {**sut_instances_amount, **tester_instances_amount}:
        start_index = find_idx(template_contents, "PHEADER")
        for file in os.listdir(root_dir+"/submodules/"+submodule_directories[i]+"/hardware/include"):
            if file.endswith(".vh"):
                testbench_contents.insert(start_index, '`include "{}"\n'.format(root_dir+"/submodules/"+submodule_directories[i]+"/hardware/include/"+file))

    # Insert PORTS and PWIRES
    for corename in sut_instances_amount:
        for i in range(sut_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signalModified = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                # Make sure this signal is mapped
                if mapped_signals[0][corename][i][signalModified] > -2:
                    if mapped_signals[0][corename][i][signalModified] == -1: # Mapped to external interface, therefore is a top_system port
                        # Insert PWIRES
                        testbench_contents.insert(find_idx(testbench_contents, "PWIRES"), '    wire {};\n'.format("sut_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                        # Insert PORTS
                        testbench_contents.insert(find_idx(testbench_contents, "PORTS"), '        .{}({}),\n'.format("sut_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal), "sut_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                else:
                    print("Error: signal {} of SUT.{}[{}] not mapped!".format(signal,corename,i))
                    exit(-1)
    for corename in tester_instances_amount:
        for i in range(tester_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signalModified = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                # Make sure this signal is mapped
                if mapped_signals[1][corename][i][signalModified] > -2:
                    if mapped_signals[1][corename][i][signalModified] == -1: # Mapped to external interface, therefore is a top_system port
                        # Insert PWIRES
                        testbench_contents.insert(find_idx(testbench_contents, "PWIRES"), '    wire {};\n'.format("tester_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                        # Insert PORTS
                        testbench_contents.insert(find_idx(testbench_contents, "PORTS"), '        .{}({}),\n'.format("tester_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal), "tester_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                else:
                    print("Error: signal {} of Tester.{}[{}] not mapped!".format(signal,corename,i))
                    exit(-1)



    # Write testbench 
    testbench_file = open("tester_tb.v", "w")
    testbench_file.writelines(testbench_contents)
    testbench_file.close()


if __name__ == "__main__":
    # Parse arguments
    if len(sys.argv)>2:
        root_dir=sys.argv[2]
        submodule_utils.root_dir = root_dir
        if sys.argv[1] == "generate_config":
           generate_portmap() 
        elif sys.argv[1] == "create_tester":
            create_tester() 
        elif sys.argv[1] == "create_testbench":
            create_testbench() 
        else:
            print("Unknown argument.\nUsage: {} <command> <root_dir>\n Commands: generate_config create_topsystem create_testbench".format(sys.argv[0]))
    else:
        print("Needs two arguments.\nUsage: {} <command> <root_dir>".format(sys.argv[0]))


