`timescale 1ns / 1ps

`include "bsp.vh"
`include "iob_soc_tester_conf.vh"
`include "iob_lib.vh"

//IOB_PRAGMA_PHEADERS

module iob_soc_tester_top (
   output                             trap_o,
   //tester uart
   input                               uart_avalid,
   input [`IOB_UART_SWREG_ADDR_W-1:0]  uart_addr,
   input [`IOB_SOC_TESTER_DATA_W-1:0]  uart_wdata,
   input [3:0]                         uart_wstrb,
   output [`IOB_SOC_TESTER_DATA_W-1:0] uart_rdata,
   output                              uart_ready,
   output                              uart_rvalid,
   `IOB_INPUT(clk_i,1), //V2TEX_IO System clock input.
   `IOB_INPUT(rst_i,1)  //V2TEX_IO System reset, asynchronous and active high.
   );
 
   localparam AXI_ID_W = 4;
   localparam AXI_LEN_W = 8;
   localparam AXI_ADDR_W=`DDR_ADDR_W;
   localparam AXI_DATA_W=`DDR_DATA_W;
 
   //IOB_PRAGMA_PWIRES

   
   /////////////////////////////////////////////
   // TEST PROCEDURE
   //
   initial begin
`ifdef VCD
      $dumpfile("tester.vcd");
      $dumpvars();
`endif
   end
   
   //
   // INSTANTIATE COMPONENTS
   //

   //DDR AXI interface signals (2 for the two systems + 1 for memory)
`ifdef IOB_SOC_TESTER_USE_EXTMEM
   `include "iob_bus_3_axi_wire.vh"
`endif

   //'Or' between trap signals of Tester and SUT
   wire [1:0]                   trap_signals;
   assign trap_o = trap_signals[0] || trap_signals[1];

    //
   // Tester (also includes Unit Under Test)
    //
   iob_soc_tester #(
      .AXI_ID_W(AXI_ID_W),
      .AXI_LEN_W(AXI_LEN_W),
      .AXI_ADDR_W(AXI_ADDR_W),
      .AXI_DATA_W(AXI_DATA_W)
      )
   tester0 (
           //IOB_PRAGMA_PPORTMAPS
`ifdef IOB_SOC_TESTER_USE_EXTMEM
      `include "iob_bus_0_2_axi_m_portmap.vh"
`endif               
      .clk_i (clk_i),
      .arst_i (rst_i),
      .trap_o (trap_signals)
      );

`ifdef IOB_SOC_TESTER_USE_EXTMEM
	//instantiate axi interconnect
	//This connects Tester+SUT to the same memory
	axi_interconnect
		#(
		.ID_WIDTH(AXI_ID_W),
		.DATA_WIDTH (AXI_DATA_W),
		.ADDR_WIDTH (AXI_ADDR_W),
		.M_ADDR_WIDTH (AXI_ADDR_W),
		.S_COUNT (2),
		.M_COUNT (1)
		)
		system_axi_interconnect(
			.clk            (clk_i),
			.rst            (rst_i),

			`include "iob_bus_0_2_s_axi_portmap.vh"
			`include "iob_bus_2_3_m_axi_portmap.vh"

			//optional signals
			.s_axi_awuser   (2'b00),
			.s_axi_wuser    (2'b00),
			.s_axi_aruser   (2'b00),
			.m_axi_buser    (1'b0),
			.m_axi_ruser    (1'b0)
		);


   //instantiate the axi memory
	//Tester and SUT access the same memory.
	axi_ram 
		#(
`ifdef IOB_SOC_TESTER_INIT_MEM
		.FILE("init_ddr_contents.hex"), //This file contains firmware for both systems
		.FILE_SIZE(2**(AXI_ADDR_W-2)),
`endif
		.ID_WIDTH (AXI_ID_W),
		.DATA_WIDTH (AXI_DATA_W),
		.ADDR_WIDTH (AXI_ADDR_W)
		)
		ddr_model_mem(
      `include "iob_bus_2_3_axi_s_portmap.vh"

      .clk_i(clk_i),
      .rst_i(rst_i)
      );   
`endif

//finish simulation on trap
/* //Sut
always @(posedge trap[0]) begin
	#10 $display("Found SUT CPU trap condition");
	$finish;
   end
//Tester
always @(posedge trap[1]) begin
	#10 $display("Found Tester CPU trap condition");
	$finish;
   end */

   //sram monitor - use for debugging programs
   /*
    wire [`IOB_SOC_TESTER_SRAM_ADDR_W-1:0] sram_daddr = uut.int_mem0.int_sram.d_addr;
    wire sram_dwstrb = |uut.int_mem0.int_sram.d_wstrb & uut.int_mem0.int_sram.d_valid;
    wire sram_drdstrb = !uut.int_mem0.int_sram.d_wstrb & uut.int_mem0.int_sram.d_valid;
    wire [`IOB_SOC_TESTER_DATA_W-1:0] sram_dwdata = uut.int_mem0.int_sram.d_wdata;


    wire sram_iwstrb = |uut.int_mem0.int_sram.i_wstrb & uut.int_mem0.int_sram.i_valid;
    wire sram_irdstrb = !uut.int_mem0.int_sram.i_wstrb & uut.int_mem0.int_sram.i_valid;
    wire [`IOB_SOC_TESTER_SRAM_ADDR_W-1:0] sram_iaddr = uut.int_mem0.int_sram.i_addr;
    wire [`IOB_SOC_TESTER_DATA_W-1:0] sram_irdata = uut.int_mem0.int_sram.i_rdata;

    
    always @(posedge sram_dwstrb)
    if(sram_daddr == 13'h090d)  begin
    #10 $display("Found CPU memory condition at %f : %x : %x", $time, sram_daddr, sram_dwdata );
    //$finish;
      end
    */
	//Manually added testbench uart core. RS232 pins attached to the same pins
	//of the Tester UART0 instance to communicate with it
	// The interface of Tester UART0 is assumed to be the first portmapped interface (portmap_0_*)
   wire cke_i = 1'b1;
   iob_uart uart_tb
     (
      .clk_i      (clk_i),
      .cke_i      (cke_i),
      .arst_i     (rst_i),
      
      .iob_avalid_i (uart_avalid),
      .iob_addr_i   (uart_addr),
      .iob_wdata_i  (uart_wdata),
      .iob_wstrb_i  (uart_wstrb),
      .iob_rdata_o  (uart_rdata),
      .iob_rvalid_o (uart_rvalid),
      .iob_ready_o  (uart_ready),
      
      .txd        (portmap_0_rxd),
      .rxd        (portmap_0_txd),
      .rts        (portmap_0_cts),
      .cts        (portmap_0_rts)
      );
   
	//Ethernet
`ifdef IOB_SOC_TESTER_USE_ETHERNET
   //ethernet clock: 4x slower than system clock
   reg [1:0] eth_cnt = 2'b0;
   reg eth_clk;

   always @(posedge clk_i) begin
       eth_cnt <= eth_cnt + 1'b1;
       eth_clk <= eth_cnt[1];
   end

   // Ethernet Interface signals
   assign ETHERNET0_RX_CLK = eth_clk;
   assign ETHERNET0_TX_CLK = eth_clk;
   assign ETHERNET0_PLL_LOCKED = 1'b1;

//add core test module in testbench
iob_eth_tb_gen eth_tb(
      .clk      (clk_i),
      .reset    (rst_i),

      // This module acts like a loopback
      .RX_CLK(ETHERNET0_TX_CLK),
      .RX_DATA(ETHERNET0_TX_DATA),
      .RX_DV(ETHERNET0_TX_EN),

      // The wires are thus reversed
      .TX_CLK(ETHERNET0_RX_CLK),
      .TX_DATA(ETHERNET0_RX_DATA),
      .TX_EN(ETHERNET0_RX_DV)
);
`endif

endmodule
