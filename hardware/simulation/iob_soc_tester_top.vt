`timescale 1ns / 1ps

`include "tester.vh"
`include "iob_lib.vh"

//PHEADER

module system_top 
  (
   output                             trap_o,
   //tester uart
   input                               uart_avalid,
   input [`IOB_UART_SWREG_ADDR_W-1:0]  uart_addr,
   input [`IOB_SOC_TESTER_DATA_W-1:0]  uart_wdata,
   input [3:0]                         uart_wstrb,
   output [`IOB_SOC_TESTER_DATA_W-1:0] uart_rdata,
   output                              uart_ready,
   output                              uart_rvalid,
   `IOB_INPUT(clk_i,1), //V2TEX_IO System clock input.
   `IOB_INPUT(rst_i,1)  //V2TEX_IO System reset, asynchronous and active high.
   );
 
   localparam AXI_ID_W = 4;
   localparam AXI_LEN_W = 8;
   localparam AXI_ADDR_W=`IOB_SOC_TESTER_DDR_ADDR_W;
   localparam AXI_DATA_W=`IOB_SOC_TESTER_DDR_DATA_W;
 
   //PWIRES

   
   /////////////////////////////////////////////
   // TEST PROCEDURE
   //
   initial begin

`ifdef VCD
      $dumpfile("tester.vcd");
      $dumpvars();
`endif

   end
   
   //
   // INSTANTIATE COMPONENTS
   //

   //DDR AXI interface signals (2 for the two systems + 1 for memory)
`ifdef RUN_EXTMEM
   //Write address
   wire [3*AXI_ID_W-1:0]     axi_awid_o;
   wire [3*AXI_ADDR_W-1:0]   axi_awaddr_o;
   wire [3*(7+1)-1:0]        axi_awlen_o;
   wire [3*(2+1)-1:0]        axi_awsize_o;
   wire [3*(1+1)-1:0]        axi_awburst_o;
   wire [3*(1+1)-1:0]        axi_awlock_o;
   wire [3*(3+1)-1:0]        axi_awcache_o;
   wire [3*(2+1)-1:0]        axi_awprot_o;
   wire [3*(3+1)-1:0]        axi_awqos_o;
   wire [2:0]                axi_awvalid_o;
   wire [2:0]                axi_awready_i;
   //Write data              
   wire [3*(31+1)-1:0]       axi_wdata_o;
   wire [3*(3+1)-1:0]        axi_wstrb_o;
   wire [2:0]                axi_wlast_o;
   wire [2:0]                axi_wvalid_o;
   wire [2:0]                axi_wready_i;
   //Write response          
   wire [3*AXI_ID_W-1:0]     axi_bid_i;
   wire [3*(1+1)-1:0]        axi_bresp_i;
   wire [2:0]                axi_bvalid_i;
   wire [2:0]                axi_bready_o;
   //Read address            
   wire [3*AXI_ID_W-1:0]     axi_arid_o;
   wire [3*AXI_ADDR_W-1:0]   axi_araddr_o;
   wire [3*(7+1)-1:0]        axi_arlen_o;
   wire [3*(2+1)-1:0]        axi_arsize_o;
   wire [3*(1+1)-1:0]        axi_arburst_o;
   wire [3*(1+1)-1:0]        axi_arlock_o;
   wire [3*(3+1)-1:0]        axi_arcache_o;
   wire [3*(2+1)-1:0]        axi_arprot_o;
   wire [3*(3+1)-1:0]        axi_arqos_o;
   wire [2:0]                axi_arvalid_o;
   wire [2:0]                axi_arready_i;
   //Read data               
   wire [3*AXI_ID_W-1:0]     axi_rid_i;
   wire [3*(31+1)-1:0]       axi_rdata_i;
   wire [3*(1+1)-1:0]        axi_rresp_i;
   wire [2:0]                axi_rlast_i;
   wire [2:0]                axi_rvalid_i;
   wire [2:0]                axi_rready_o;
`endif

   //'Or' between trap signals of Tester and SUT
   wire [1:0]                   trap_signals;
   assign trap = trap_signals[0] || trap_signals[1];

   //
   // Tester (also includes Unit Under Test)
   //
   tester 
     #(
       .AXI_ID_W(AXI_ID_W),
       .AXI_LEN_W(AXI_LEN_W),
       .AXI_ADDR_W(AXI_ADDR_W),
       .AXI_DATA_W(AXI_DATA_W)
       )
	tester0 (
           //PORTS
`ifdef IOB_SOC_TESTER_USE_DDR
           //address write
	       .axi_awid_o  (axi_awid_o      [2*AXI_ID_W-1:0]),
	       .axi_awaddr  (axi_awaddr_o    [2*AXI_ADDR_W-1:0]),
	       .axi_awlen   (axi_awlen_o     [2*(7+1)-1:0]),
	       .axi_awsize  (axi_awsize_o    [2*(2+1)-1:0]),
	       .axi_awburst (axi_awburst_o   [2*(1+1)-1:0]),
	       .axi_awlock  (axi_awlock_o    [2*(1+1)-1:0]),
	       .axi_awcache (axi_awcache_o   [2*(3+1)-1:0]),
	       .axi_awprot  (axi_awprot_o    [2*(2+1)-1:0]),
	       .axi_awqos   (axi_awqos_o     [2*(3+1)-1:0]),
	       .axi_awvalid (axi_awvalid_o   [1:0]),
	       .axi_awready (axi_awready_i   [1:0]),
	       //write                       
	       .axi_wdata   (axi_wdata_o     [2*(31+1)-1:0]),
	       .axi_wstrb   (axi_wstrb_o     [2*(3+1)-1:0]),
	       .axi_wlast   (axi_wlast_o     [1:0]),
	       .axi_wvalid  (axi_wvalid_o    [1:0]),
	       .axi_wready  (axi_wready_i    [1:0]),
	       //write response              
	       .axi_bid     (axi_bid_i       [2*AXI_ID_W-1:0]),
	       .axi_bresp   (axi_bresp_i     [2*(1+1)-1:0]),
	       .axi_bvalid  (axi_bvalid_i    [1:0]),
	       .axi_bready  (axi_bready_o    [1:0]),
	       //address read                
	       .axi_arid    (axi_arid_o      [2*AXI_ID_W-1:0]),
	       .axi_araddr  (axi_araddr_o    [2*AXI_ADDR_W-1:0]),
	       .axi_arlen   (axi_arlen_o     [2*(7+1)-1:0]),
	       .axi_arsize  (axi_arsize_o    [2*(2+1)-1:0]),
	       .axi_arburst (axi_arburst_o   [2*(1+1)-1:0]),
	       .axi_arlock  (axi_arlock_o    [2*(1+1)-1:0]),
	       .axi_arcache (axi_arcache_o   [2*(3+1)-1:0]),
	       .axi_arprot  (axi_arprot_o    [2*(2+1)-1:0]),
	       .axi_arqos   (axi_arqos_o     [2*(3+1)-1:0]),
	       .axi_arvalid (axi_arvalid_o   [1:0]),
	       .axi_arready (axi_arready_i   [1:0]),
	       //read                        
	       .axi_rid     (axi_rid_i       [2*AXI_ID_W-1:0]),
	       .axi_rdata   (axi_rdata_i     [2*(31+1)-1:0]),
	       .axi_rresp   (axi_rresp_i     [2*(1+1)-1:0]),
	       .axi_rlast   (axi_rlast_i     [1:0]),
	       .axi_rvalid  (axi_rvalid_i    [1:0]),
	       .axi_rready  (axi_rready_o    [1:0]),	
`endif               
	       .general_clk_i         (clk_i),
	       .general_rst_i         (rst_i),
	       .general_trap_o        (trap_signals)
	       );

`ifdef IOB_SOC_TESTER_USE_DDR
	//instantiate axi interconnect
	//This connects Tester+SUT to the same memory
	axi_interconnect
		#(
		.ID_WIDTH(AXI_ID_W),
		.DATA_WIDTH (AXI_DATA_W),
		.ADDR_WIDTH (AXI_ADDR_W),
		.M_ADDR_WIDTH (AXI_ADDR_W),
		.S_COUNT (2),
		.M_COUNT (1)
		)
		system_axi_interconnect(
			.clk            (clk_i),
			.rst            (rst_i),

			.s_axi_awid     (axi_awid_o      [2*AXI_ID_W-1:0]),
			.s_axi_awaddr   (axi_awaddr_o    [2*AXI_ADDR_W-1:0]),
			.s_axi_awlen    (axi_awlen_o     [2*(7+1)-1:0]),
			.s_axi_awsize   (axi_awsize_o    [2*(2+1)-1:0]),
			.s_axi_awburst  (axi_awburst_o   [2*(1+1)-1:0]),
			.s_axi_awlock   ({axi_awlock_o[2],axi_awlock_o[0]}),
			.s_axi_awcache  (m_axi_awcache    axi_awcache_o   [2*(3+1)-1:0]),
			.s_axi_awprot   (axi_awprot_o    [2*(2+1)-1:0]),
			.s_axi_awqos    (axi_awqos_o     [2*(3+1)-1:0]),
			.s_axi_awvalid  (axi_awvalid_o   [1:0]),
			.s_axi_awready  (axi_awready_i   [1:0]),
			//write                                        
			.s_axi_wdata    (axi_wdata_o     [2*(31+1)-1:0]),
			.s_axi_wstrb    (axi_wstrb_o     [2*(3+1)-1:0]),
			.s_axi_wlast    (axi_wlast_o     [1:0]),
			.s_axi_wvalid   (axi_wvalid_o    [1:0]),
			.s_axi_wready   (axi_wready_i    [1:0]),
			//write response                  se           
			.s_axi_bid      (axi_bid_i       [2*AXI_ID_W-1:0]),
			.s_axi_bresp    (axi_bresp_i     [2*(1+1)-1:0]),
			.s_axi_bvalid   (axi_bvalid_i    [1:0]),
			.s_axi_bready   (axi_bready_o    [1:0]),
			//address read                                 
			.s_axi_arid     (axi_arid_o      [2*AXI_ID_W-1:0]),
			.s_axi_araddr   (axi_araddr_o    [2*AXI_ADDR_W-1:0]),
			.s_axi_arlen    (axi_arlen_o     [2*(7+1)-1:0]), 
			.s_axi_arsize   (axi_arsize_o    [2*(2+1)-1:0]),    
			.s_axi_arburst  (axi_arburst_o   [2*(1+1)-1:0]),
			.s_axi_arlock   ({axi_arlock_o[2],axi_arlock_o[0]}),
			.s_axi_arcache  (axi_arcache_o   [2*(3+1)-1:0]),
			.s_axi_arprot   (axi_arprot_o    [2*(2+1)-1:0]),
			.s_axi_arqos    (axi_arqos_o     [2*(3+1)-1:0]),
			.s_axi_arvalid  (axi_arvalid_o   [1:0]),
			.s_axi_arready  (axi_arready_i   [1:0]),
			//read                                         
			.s_axi_rid      (axi_rid_i       [2*AXI_ID_W-1:0]),
			.s_axi_rdata    (axi_rdata_i     [2*(31+1)-1:0]),
			.s_axi_rresp    (axi_rresp_i     [2*(1+1)-1:0]),
			.s_axi_rlast    (axi_rlast_i     [1:0]),
			.s_axi_rvalid   (axi_rvalid_i    [1:0]),
			.s_axi_rready   (axi_rready_o    [1:0]),

			.m_axi_awid     (axi_awid_o      [3*AXI_ID_W-1:2*AXI_ID_W]),
			.m_axi_awaddr   (axi_awaddr_o    [3*AXI_ADDR_W-1:2*AXI_ADDR_W]),
			.m_axi_awlen    (axi_awlen_o     [3*(7+1)-1:2*(7+1)]),
			.m_axi_awsize   (axi_awsize_o    [3*(2+1)-1:2*(2+1)]),
			.m_axi_awburst  (axi_awburst_o   [3*(1+1)-1:2*(1+1)]),
			.m_axi_awlock   (axi_awlock_o    [4]),
			.m_axi_awcache  (axi_awcache_o   [3*(3+1)-1:2*(3+1)]),
			.m_axi_awprot   (axi_awprot_o    [3*(2+1)-1:2*(2+1)]),
			.m_axi_awqos    (axi_awqos_o     [3*(3+1)-1:2*(3+1)]),
			.m_axi_awvalid  (axi_awvalid_o   [2]),
			.m_axi_awready  (axi_awready_i   [2]),
			//write                                        
			.m_axi_wvalid   (axi_wvalid_o    [2]),
			.m_axi_wready   (axi_wready_i    [2]),
			.m_axi_wdata    (axi_wdata_o     [3*(31+1)-1:2*(31+1)]),
			.m_axi_wstrb    (axi_wstrb_o     [3*(3+1)-1:2*(3+1)]),
			.m_axi_wlast    (axi_wlast_o     [2]),
			//write response                  se           
			.m_axi_bready   (axi_bready_o    [2]),
			.m_axi_bid      (axi_bid_i       [3*AXI_ID_W-1:2*AXI_ID_W]),
			.m_axi_bresp    (axi_bresp_i     [3*(1+1)-1:2*(1+1)]),
			.m_axi_bvalid   (axi_bvalid_i    [2]),
			//address read                                 
			.m_axi_arid     (axi_arid_o      [3*AXI_ID_W-1:2*AXI_ID_W]),
			.m_axi_araddr   (axi_araddr_o    [3*AXI_ADDR_W-1:2*AXI_ADDR_W]),
			.m_axi_arlen    (axi_arlen_o     [3*(7+1)-1:2*(7+1)]), 
			.m_axi_arsize   (axi_arsize_o    [3*(2+1)-1:2*(2+1)]),    
			.m_axi_arburst  (axi_arburst_o   [3*(1+1)-1:2*(1+1)]),
			.m_axi_arlock   (axi_arlock_o    [4]),
			.m_axi_arcache  (axi_arcache_o   [3*(3+1)-1:2*(3+1)]),
			.m_axi_arprot   (axi_arprot_o    [3*(2+1)-1:2*(2+1)]),
			.m_axi_arqos    (axi_arqos_o     [3*(3+1)-1:2*(3+1)]),
			.m_axi_arvalid  (axi_arvalid_o   [2]),
			.m_axi_arready  (axi_arready_i   [2]),
			//read                                         
			.m_axi_rdata    (axi_rdata_i     [3*(31+1)-1:2*(31+1)]),
			.m_axi_rresp    (axi_rresp_i     [3*(1+1)-1:2*(1+1)]),
			.m_axi_rlast    (axi_rlast_i     [2]),
			.m_axi_rvalid   (axi_rvalid_i    [2]),
			.m_axi_rid      (axi_rid_i       [3*AXI_ID_W-1:2*AXI_ID_W]),
			.m_axi_rready   (axi_rready_o    [2]),

			//optional signals
			.s_axi_awuser   (2'b00),
			.s_axi_wuser    (2'b00),
			.s_axi_aruser   (2'b00),
			.m_axi_buser    (1'b0),
			.m_axi_ruser    (1'b0)
		);


   //instantiate the axi memory 
	//Tester and SUT access the same memory.
	axi_ram 
		#(
		`ifdef IOB_SOC_TESTER_DDR_INIT
		.FILE("init_ddr_contents.hex"), //This file contains firmware for both systems
		.FILE_SIZE(2**(AXI_ADDR_W-2)),
		`endif
		.ID_WIDTH (AXI_ID_W),
		.DATA_WIDTH (AXI_DATA_W),
		.ADDR_WIDTH (AXI_ADDR_W)
		)
		ddr_model_mem(
			//address write
			.clk            (clk_i),
			.rst            (rst_i),

			.s_axi_awid     (axi_awid_o      [3*AXI_ID_W-1:2*AXI_ID_W]),
			.s_axi_awaddr   (axi_awaddr_o    [3*AXI_ADDR_W-1:2*AXI_ADDR_W]),
			.s_axi_awlen    (axi_awlen_o     [3*(7+1)-1:2*(7+1)]),
			.s_axi_awsize   (axi_awsize_o    [3*(2+1)-1:2*(2+1)]),
			.s_axi_awburst  (axi_awburst_o   [3*(1+1)-1:2*(1+1)]),
			.s_axi_awlock   (axi_awlock_o    [3*(1+1)-1:2*(1+1)]),
			.s_axi_awcache  (axi_awcache_o   [3*(3+1)-1:2*(3+1)]),
			.s_axi_awprot   (axi_awprot_o    [3*(2+1)-1:2*(2+1)]),
			.s_axi_awqos    (axi_awqos_o     [3*(3+1)-1:2*(3+1)]),
			.s_axi_awvalid  (axi_awvalid_o   [2]),
			.s_axi_awready  (axi_awready_i   [2]),
			//write                                              
			.s_axi_wvalid   (axi_wvalid_o    [2]),
			.s_axi_wready   (axi_wready_i    [2]),
			.s_axi_wdata    (axi_wdata_o     [3*(31+1)-1:2*(31+1)]),
			.s_axi_wstrb    (axi_wstrb_o     [3*(3+1)-1:2*(3+1)]),
			.s_axi_wlast    (axi_wlast_o     [2]),
			//write response                                     
			.s_axi_bready   (axi_bready_o    [2]),
			.s_axi_bid      (axi_bid_i       [3*AXI_ID_W-1:2*AXI_ID_W]),
			.s_axi_bresp    (axi_bresp_i     [3*(1+1)-1:2*(1+1)]),
			.s_axi_bvalid   (axi_bvalid_i    [2]),
			//address read                                       
			.s_axi_arid     (axi_arid_o      [3*AXI_ID_W-1:2*AXI_ID_W]),
			.s_axi_araddr   (axi_araddr_o    [3*AXI_ADDR_W-1:2*AXI_ADDR_W]),
			.s_axi_arlen    (axi_arlen_o     [3*(7+1)-1:2*(7+1)]), 
			.s_axi_arsize   (axi_arsize_o    [3*(2+1)-1:2*(2+1)]),    
			.s_axi_arburst  (axi_arburst_o   [3*(1+1)-1:2*(1+1)]),
			.s_axi_arlock   (axi_arlock_o    [3*(1+1)-1:2*(1+1)]),
			.s_axi_arcache  (axi_arcache_o   [3*(3+1)-1:2*(3+1)]),
			.s_axi_arprot   (axi_arprot_o    [3*(2+1)-1:2*(2+1)]),
			.s_axi_arqos    (axi_arqos_o     [3*(3+1)-1:2*(3+1)]),
			.s_axi_arvalid  (axi_arvalid_o   [2]),
			.s_axi_arready  (axi_arready_i   [2]),
			//read                                               
			.s_axi_rdata    (axi_rdata_i     [3*(31+1)-1:2*(31+1)]),
			.s_axi_rresp    (axi_rresp_i     [3*(1+1)-1:2*(1+1)]),
			.s_axi_rlast    (axi_rlast_i     [2]),
			.s_axi_rvalid   (axi_rvalid_i    [2])
			.s_axi_rid      (axi_rid_i       [3*AXI_ID_W-1:2*AXI_ID_W]),
			.s_axi_rready   (axi_rready_o    [2]),
		);   
`endif


//finish simulation on trap
/* //Sut
always @(posedge trap[0]) begin
	#10 $display("Found SUT CPU trap condition");
	$finish;
   end
//Tester
always @(posedge trap[1]) begin
	#10 $display("Found Tester CPU trap condition");
	$finish;
   end */

   //sram monitor - use for debugging programs
   /*
    wire [`IOB_SOC_SRAM_ADDR_W-1:0] sram_daddr = uut.int_mem0.int_sram.d_addr;
    wire sram_dwstrb = |uut.int_mem0.int_sram.d_wstrb & uut.int_mem0.int_sram.d_valid;
    wire sram_drdstrb = !uut.int_mem0.int_sram.d_wstrb & uut.int_mem0.int_sram.d_valid;
    wire [`IOB_SOC_DATA_W-1:0] sram_dwdata = uut.int_mem0.int_sram.d_wdata;


    wire sram_iwstrb = |uut.int_mem0.int_sram.i_wstrb & uut.int_mem0.int_sram.i_valid;
    wire sram_irdstrb = !uut.int_mem0.int_sram.i_wstrb & uut.int_mem0.int_sram.i_valid;
    wire [`IOB_SOC_SRAM_ADDR_W-1:0] sram_iaddr = uut.int_mem0.int_sram.i_addr;
    wire [`IOB_SOC_DATA_W-1:0] sram_irdata = uut.int_mem0.int_sram.i_rdata;

    
    always @(posedge sram_dwstrb)
    if(sram_daddr == 13'h090d)  begin
    #10 $display("Found CPU memory condition at %f : %x : %x", $time, sram_daddr, sram_dwdata );
    //$finish;
      end
    */
  wire en_i = 1'b1;
	//Manually added testbench uart core. RS232 pins attached to the same pins
	//of the Tester UART0 instance to communicate with it
	// The interface of Tester UART0 is assumed to be the first portmapped interface (portmap_0_*)
   wire cke_i = 1'b1;
   iob_uart uart_tb
     (
      .clk_i      (clk_i),
      .cke_i      (cke_i),
      .arst_i     (rst_i),
      
      .iob_avalid (uart_avalid),
      .iob_addr   (uart_addr),
      .iob_wdata  (uart_wdata),
      .iob_wstrb  (uart_wstrb),
      .iob_rdata  (uart_rdata),
      .iob_rvalid (uart_rvalid),
      .iob_ready  (uart_ready),
      
      .txd        (portmap_0_rxd),
      .rxd        (portmap_0_txd),
      .rts        (portmap_0_cts),
      .cts        (portmap_0_rts)
      );
   
	//Ethernet
`ifdef IOB_SOC_TESTER_USE_ETHERNET
   //ethernet clock: 4x slower than system clock
   reg [1:0] eth_cnt = 2'b0;
   reg eth_clk;

   always @(posedge clk_i) begin
       eth_cnt <= eth_cnt + 1'b1;
       eth_clk <= eth_cnt[1];
   end

   // Ethernet Interface signals
   assign ETHERNET0_RX_CLK = eth_clk;
   assign ETHERNET0_TX_CLK = eth_clk;
   assign ETHERNET0_PLL_LOCKED = 1'b1;

//add core test module in testbench
iob_eth_tb_gen eth_tb(
      .clk      (clk_i),
      .reset    (rst_i),

      // This module acts like a loopback
      .RX_CLK(ETHERNET0_TX_CLK),
      .RX_DATA(ETHERNET0_TX_DATA),
      .RX_DV(ETHERNET0_TX_EN),

      // The wires are thus reversed
      .TX_CLK(ETHERNET0_RX_CLK),
      .TX_DATA(ETHERNET0_RX_DATA),
      .TX_EN(ETHERNET0_RX_DV)
);
`endif

endmodule
