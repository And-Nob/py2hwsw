#!/usr/bin/env python3
# It has functions to auto generate a template portmap based on peripherals list
# It's also used to read the portmap file, verify its correctness and generate tester.v that includes the SUT instance 

import sys
import subprocess
import os
import re

# Add folder to path that contains python scripts to be imported
import submodule_utils 
from submodule_utils import *

# Header to be put in portmap config file
portmap_header = """\
//********************************************************************************************************************************
// Use this file to configure port mapping between the Tester peripherals, SUT peripherals and external interface of the Tester.
// This file was auto-generated by the 'make tester-config' target (tester_utils.py)
// Port map syntax:
//    Tester.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : External
//    SUT.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : External
//    Tester.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : SUT.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name>
//      or
//    SUT.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : Tester.<peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name>
// Example, to connect UART instance number 1 of SUT to UART instance number 0 of Tester:
//    Tester.UART[0].UART_txd : SUT.UART[1].UART_rxd
//    Tester.UART[0].UART_rxd : SUT.UART[1].UART_txd
//    Tester.UART[0].UART_rts : SUT.UART[1].UART_cts
//    Tester.UART[0].UART_cts : SUT.UART[1].UART_rts
// Example, to connect UART instance number 0 of SUT to a dedicated external interface of the tester: 
//    SUT.UART[0].UART_rxd : External
//    SUT.UART[0].UART_txd : External
//    SUT.UART[0].UART_cts : External
//    SUT.UART[0].UART_rts : External
//********************************************************************************************************************************
// Auto-generated list of signals to be mapped (by default mapped to external interface):
"""

# SUT instance to be included in tester
sut_instance_template = """\
system sut (
    //SUTPORTS

`ifdef USE_DDR
    //address write
    .m_axi_awid    (m_axi_awid),
    .m_axi_awaddr  (m_axi_awaddr),
    .m_axi_awlen   (m_axi_awlen),
    .m_axi_awsize  (m_axi_awsize),
    .m_axi_awburst (m_axi_awburst),
    .m_axi_awlock  (m_axi_awlock),
    .m_axi_awcache (m_axi_awcache),
    .m_axi_awprot  (m_axi_awprot),
    .m_axi_awqos   (m_axi_awqos),
    .m_axi_awvalid (m_axi_awvalid),
    .m_axi_awready (m_axi_awready),

    //write  
    .m_axi_wdata   (m_axi_wdata),
    .m_axi_wstrb   (m_axi_wstrb),
    .m_axi_wlast   (m_axi_wlast),
    .m_axi_wvalid  (m_axi_wvalid),
    .m_axi_wready  (m_axi_wready),

    //write response
    .m_axi_bid     (m_axi_bid),
    .m_axi_bresp   (m_axi_bresp),
    .m_axi_bvalid  (m_axi_bvalid),
    .m_axi_bready  (m_axi_bready),

    //address read
    .m_axi_arid    (m_axi_arid),
    .m_axi_araddr  (m_axi_araddr),
    .m_axi_arlen   (m_axi_arlen),
    .m_axi_arsize  (m_axi_arsize),
    .m_axi_arburst (m_axi_arburst),
    .m_axi_arlock  (m_axi_arlock),
    .m_axi_arcache (m_axi_arcache),
    .m_axi_arprot  (m_axi_arprot),
    .m_axi_arqos   (m_axi_arqos),
    .m_axi_arvalid (m_axi_arvalid),
    .m_axi_arready (m_axi_arready),

    //read   
    .m_axi_rid     (m_axi_rid),
    .m_axi_rdata   (m_axi_rdata),
    .m_axi_rresp   (m_axi_rresp),
    .m_axi_rlast   (m_axi_rlast),
    .m_axi_rvalid  (m_axi_rvalid),
    .m_axi_rready  (m_axi_rready),	
`endif               
    .clk           (clk),
    .reset         (reset),
    .trap          (trap[0])
    );
"""

# Parameter: TESTER_PERIPHERALS string defined in config.mk
# Returns dictionary with amount of instances each peripheral of the Tester to be created 
def get_tester_peripherals(tester_peripherals_str):
    tester_peripherals = tester_peripherals_str.split()

    tester_instances_amount = {}
    for i in tester_peripherals:
        tester_instances_amount[i]=tester_peripherals.count(i)

    return tester_instances_amount


# Overwrites portmap configuration file with a template, with every existing signal mapped to external interface by default
def generate_portmap(directories_str, sut_peripherals_str, tester_peripherals_str):
    sut_instances_amount = get_sut_peripherals(sut_peripherals_str)
    tester_instances_amount = get_tester_peripherals(tester_peripherals_str)
    submodule_directories = get_submodule_directories(directories_str)
    peripheral_signals = get_peripherals_signals({**sut_instances_amount, **tester_instances_amount},submodule_directories)

    # Generate portmap file
    portmap_file = open(root_dir+"/hardware/tester/peripheral_portmap.txt", "w")
    portmap_file.write(portmap_header)

    # Create signals for every peripheral instance
    for corename in sut_instances_amount:
        for i in range(sut_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signal = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                portmap_file.write("SUT.{}[{}].{} : External\n".format(corename,i,signal))
    portmap_file.write("//Tester peripheral signals (you can remove some of these signals and map them to the SUT signals above instead)\n")
    for corename in tester_instances_amount:
        for i in range(tester_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signal = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                portmap_file.write("Tester.{}[{}].{} : External\n".format(corename,i,signal))
    portmap_file.close()

# Reads portmap file
# Returns:
#    pwires: List of signals that will interconnect SUT with Tester peripherals. Each signal is an array with 2 dimensions. [0] is the signal name. [1] is the signal size.
#    mapped_signals: Dimensions=[<0 for SUT; 1 for Tester>][<corename>][<instance number>][<signal name with macro>]
#                    This list of dictionaries stores the -2 for unmapped signals, -1 for mapped to external interface 
#                    and >0 for signals mapped to a wire in pwires list with that index.
def read_portmap(sut_instances_amount, tester_instances_amount, peripheral_signals):
    # Wires internal to Tester that interface SUT and Tester peripherals
    pwires = []
    # Array to store if a signal has been mapped
    # -2 not mapped, -1 mapped to external interface, 0< mapped to signal in pwires (index)
    mapped_signals = [{},{}] # SUT signals and Tester Signals
    for corename in sut_instances_amount:
        mapped_signals[0][corename] = []
        for i in range(sut_instances_amount[corename]):
            mapped_signals[0][corename].append({})
            for signal in peripheral_signals[corename]:
                signal = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                mapped_signals[0][corename][i][signal] = -2
    for corename in tester_instances_amount:
        mapped_signals[1][corename] = []
        for i in range(tester_instances_amount[corename]):
            mapped_signals[1][corename].append({})
            for signal in peripheral_signals[corename]:
                signal = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                mapped_signals[1][corename][i][signal] = -2

    # Read portmap file
    portmap_file = open(root_dir+"/hardware/tester/peripheral_portmap.txt", "r")
    portmap_contents = portmap_file.readlines() 
    portmap_file.close()

    # Parse signals, map them and create pwires signals
    for idx, i in enumerate(portmap_contents):
        if i.startswith("//"): # Ignore comments
            continue
        i=i.replace(" ", "") # Remove all spaces
        result = re.search("^([^\.]+)\.([^\[]+)\[(\d+)\]\.([^\:]+)\:(?:(?:External)|(?:([^\.\n]+)\.([^\[]+)\[(\d+)\]\.(.+)))$", i)
        if result is None:
            print("Error parsing line {} of portmap file!".format(idx+1))
            exit(-1)
        try:
            # Make sure it has not been mapped before
            if not (mapped_signals[0 if result.group(1)=="SUT" else 1][result.group(2)][int(result.group(3))][result.group(4)] < -1):
                print("Error: Portmap file line {}, Signal {} of {}.{}[{}] already mapped previously!".format(idx+1,result.group(4),result.group(1),result.group(2),result.group(3)))
                exit(-1)
            if result.group(5) is None: # Mapped to external interface
                    mapped_signals[0 if result.group(1)=="SUT" else 1][result.group(2)][int(result.group(3))][result.group(4)] = -1
            else: # Mapped between SUT and Tester
                if result.group(1) == result.group(5): # Make sure we are not mapping SUT or Tester with itself 
                    print("Error: Portmap file line {}, can't map ports of {} with itself!".format(idx+1,result.group(1)))
                    exit(-1)
                # Make sure it has not been mapped before
                if not (mapped_signals[0 if result.group(5)=="SUT" else 1][result.group(6)][int(result.group(7))][result.group(8)] < -1):
                    print("Error: Portmap file line {}, Signal {} of {}.{}[{}] already mapped previously!".format(idx+1,result.group(8),result.group(5),result.group(6),result.group(7)))
                    exit(-1)
                # Get signal with macro
                signalWithMacro = [result.group(4).replace(result.group(2),"/*<InstanceName>*/"),result.group(8).replace(result.group(6),"/*<InstanceName>*/")]
                # Make sure we are connecting an input and an output
                if ("input" in peripheral_signals[result.group(2)][signalWithMacro[0]] and "input" in peripheral_signals[result.group(6)][signalWithMacro[1]]) or\
                   ("output" in peripheral_signals[result.group(2)][signalWithMacro[0]] and "output" in peripheral_signals[result.group(6)][signalWithMacro[1]]):
                    print("Error: Portmap file line {}, can't connect because both signals are of type {}!".format(idx+1,"input" if "input" in peripheral_signals[result.group(2)][signalWithMacro[0]] else "output"))
                    exit(-1)
                signal1_size = re.search("(?:input|output)(.+)",peripheral_signals[result.group(2)][signalWithMacro[0]]).group(1).replace(" ", "")
                signal2_size = re.search("(?:input|output)(.+)",peripheral_signals[result.group(6)][signalWithMacro[1]]).group(1).replace(" ", "")
                # Make sure signals have the same size (give warning if we are not sure, because it may be a macro)
                if (signal1_size!=signal2_size):
                    print("Note: Portmap file line {}, signals have sizes {} and {}. These may or may not be equal!".format(idx+1,signal1_size,signal2_size))
                # Create pwires signal to merge them
                pwires.append(["merge_{}_{}_{}_with_{}_{}_{}".format(result.group(1),result.group(4),result.group(3),result.group(5),result.group(8),result.group(7)),signal1_size])
                # Store index of pwires signal in mapping
                mapped_signals[0 if result.group(1)=="SUT" else 1][result.group(2)][int(result.group(3))][result.group(4)] = len(pwires)-1
                mapped_signals[0 if result.group(5)=="SUT" else 1][result.group(6)][int(result.group(7))][result.group(8)] = len(pwires)-1
        except KeyError as e:
            print("Error: Portmap file line {}, unknown parameter {}!".format(idx+1,e))
            exit(-1)
        except IndexError as e:
            print("Error: Portmap file line {}, could not find peripheral with index given!".format(idx+1))
            exit(-1)

    #print(pwires) #DEBUG
    #print(mapped_signals) #DEBUG
    return pwires, mapped_signals

# Creates tester.v with SUT included 
def create_tester(directories_str, sut_peripherals_str, tester_peripherals_str):
    # Get lists of peripherals and info about them
    sut_instances_amount = get_sut_peripherals(sut_peripherals_str)
    tester_instances_amount = get_tester_peripherals(tester_peripherals_str)
    submodule_directories = get_submodule_directories(directories_str)
    peripheral_signals = get_peripherals_signals({**sut_instances_amount, **tester_instances_amount},submodule_directories)

    # Read portmap file and get encoded data
    pwires, mapped_signals = read_portmap(sut_instances_amount, tester_instances_amount, peripheral_signals)

    # Read template file
    tester_template_file = open(root_dir+"/hardware/src/system_core.v", "r") 
    tester_contents = tester_template_file.readlines() 
    tester_template_file.close()

    # Insert headers of peripherals of both systems
    for i in {**sut_instances_amount, **tester_instances_amount}:
        path = root_dir+"/"+submodule_directories[i]+"/hardware/include"
        start_index = find_idx(tester_contents, "PHEADER")
        for file in os.listdir(path):
            if file.endswith(".vh") and not any(x in file for x in ["pio","inst","swreg"]):
                tester_contents.insert(start_index, '`include "{}"\n'.format(path+"/"+file))
            if file.endswith("swreg.vh"):
                tester_contents.insert(start_index, '`include "{}"\n'.format(file.replace("swreg","swreg_def")))

    # Create PWIRES marker
    tester_contents.insert(find_idx(tester_contents, "endmodule")-1, '    //PWIRES\n')

    # Rename verilog module form 'system' to 'tester'
    tester_contents[find_idx(tester_contents, "module system")-1] = "module tester\n"

    # Add another trap signal for tester cpu
    tester_contents = [re.sub('output(\s+)trap', 'output [1:0]\g<1>trap', i) for i in tester_contents] 
    # Attach tester cpu to instance 0 of trap signal array
    tester_contents = [re.sub('\(trap\)', '(trap[1])', i) for i in tester_contents] 

    axi_sizes = {} #Store axi signal sizes 
    # Add another AXI bus for Tester memory
    for i in range(len(tester_contents)):
        strMatch = re.search('((?:output)|(?:input))\s+(?:\[([^\:]+)[^\]]+\])?\s+(m_axi_[^,]+),', tester_contents[i])
        if not strMatch:
            continue
        if strMatch[2]==None or strMatch[2]=="0":
            tester_contents[i]="   {} [1:0] {},\n".format(strMatch[1],strMatch[3])
            axi_sizes[strMatch[3]]="0"
        else:
            tester_contents[i]="   {} [2*({}+1)-1:0] {},\n".format(strMatch[1],strMatch[2],strMatch[3])
            axi_sizes[strMatch[3]]=strMatch[2]
    # Change Tester AXI interface to use instance 1 of AXI bus array
    for i in range(len(tester_contents)):
        strMatch = re.search('\((m_axi_[^\)]+)\)', tester_contents[i])
        if not strMatch:
            continue
        tester_contents[i]=re.sub('\(m_axi_[^\)]+\)', '({}[2*({}+1)-1:{}+1])'.format(strMatch[1],axi_sizes[strMatch[1]],axi_sizes[strMatch[1]]), tester_contents[i])

    # Insert SUT instance (includes SUTPORTS marker)
    start_index = find_idx(tester_contents, "endmodule")-1
    sut_instance_template_array = sut_instance_template.splitlines(True)
    for i in range(len(sut_instance_template_array)):
        strMatch = re.search('\((m_axi_[^\)]+)\)', sut_instance_template_array[i])
        if not strMatch:
            continue
        sut_instance_template_array[i]=re.sub('\(m_axi_[^\)]+\)', '({}[{}:0])'.format(strMatch[1],axi_sizes[strMatch[1]]), sut_instance_template_array[i])
    tester_contents = tester_contents[:start_index] + sut_instance_template_array + tester_contents[start_index:] 

    # Invert tester memory access bit
    start_index = find_idx(tester_contents, "ext_mem ")-1
    tester_contents.insert(start_index, "`endif\n")
    tester_contents.insert(start_index, "   assign m_axi_awaddr[2*`DDR_ADDR_W-1] = axi_invert_w_bit;\n")
    tester_contents.insert(start_index, "   assign m_axi_araddr[2*`DDR_ADDR_W-1] = axi_invert_r_bit;\n")
    tester_contents.insert(start_index, "   //Dont invert bits if we dont run firmware of both systems from the DDR\n")
    tester_contents.insert(start_index, "`else\n")
    tester_contents.insert(start_index, "   assign m_axi_awaddr[2*`DDR_ADDR_W-1] = ~axi_invert_w_bit;\n")
    tester_contents.insert(start_index, "   assign m_axi_araddr[2*`DDR_ADDR_W-1] = ~axi_invert_r_bit;\n")
    tester_contents.insert(start_index, "`ifdef RUN_EXTMEM_USE_SRAM\n")
    tester_contents.insert(start_index, "   wire axi_invert_w_bit;\n")
    tester_contents.insert(start_index, "   wire axi_invert_r_bit;\n")
    tester_contents = [re.sub('.axi_awaddr\(m_axi_awaddr\[[^\]]+\]\),', '.axi_awaddr({axi_invert_w_bit,m_axi_awaddr[2*`DDR_ADDR_W-2:`DDR_ADDR_W]}),', i) for i in tester_contents]
    tester_contents = [re.sub('.axi_araddr\(m_axi_araddr\[[^\]]+\]\),', '.axi_araddr({axi_invert_r_bit,m_axi_araddr[2*`DDR_ADDR_W-2:`DDR_ADDR_W]}),', i) for i in tester_contents]

    # Replace N_SLAVES by TESTER_N_SLAVES
    tester_contents = [re.sub('`N_SLAVES', '`TESTER_N_SLAVES', i) for i in tester_contents] 

    #Insert parameters on int_mem to load with tester firmware
    int_mem_template = """\
    int_mem
         #(.HEXFILE("tester_firmware"),
           .BOOT_HEXFILE("tester_boot"))
        int_mem0
    """
    start_index = find_idx(tester_contents, "int_mem ")-1
    tester_contents.pop(start_index)
    tester_contents = tester_contents[:start_index] + int_mem_template.splitlines(True) + tester_contents[start_index:]

    # Insert Tester peripherals
    for corename in tester_instances_amount:
        # Read inst.vh file
        instv_file = open(root_dir+"/"+submodule_directories[corename]+"/hardware/include/inst.vh", "r")
        instv_contents = instv_file.readlines() 
        # Insert for every instance
        for i in range(tester_instances_amount[corename]):
            # Insert peripheral instance
            start_index = find_idx(tester_contents, "endmodule")-1
            for j in reversed(instv_contents):
                # Check if this line contains a signal of PIO
                strMatch = re.search("\((\/\*<InstanceName>\*\/[^\)]+)\)",j)
                if strMatch and strMatch[1] in peripheral_signals[corename]:
                    # Line contains a pio.vh signal, therefore change signal name to match PIO or PWIRES
                    signalModified = re.sub("\/\*<InstanceName>\*\/",corename,strMatch[1])
                    if mapped_signals[1][corename][i][signalModified] > -1: # Not mapped to external interface
                        # Signal is connected to corresponding pwires
                        tester_contents.insert(start_index, re.sub("\/\*<InstanceName>\*\/[^\)]+",pwires[mapped_signals[1][corename][i][signalModified]][0],j))
                    else: # Mapped to external interface
                        # Signal is connected to corresponding pio
                        tester_contents.insert(start_index, re.sub("\/\*<InstanceName>\*\/","tester_"+corename+str(i),j))
                else:
                    # Replace instace name verilog defines with tester defines (Because their values are different from SUT defines)
                    j = re.sub("`\/\*<InstanceName>\*\/","`TESTER_"+corename+str(i),j)
                    # Line did not contain any pio signal, so just insert it
                    # Also, replace instance name macros if their not verilog defines
                    tester_contents.insert(start_index, re.sub("\/\*<InstanceName>\*\/",corename+str(i),j))
        instv_file.close()

    # Array to store if pwires have been inserted
    pwires_inserted = [0] * len(pwires)
    # Insert PIO, PWIRES, SUTPORTS 
    for corename in sut_instances_amount:
        for i in range(sut_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signalModified = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                # Make sure this signal is mapped
                if mapped_signals[0][corename][i][signalModified] > -2:
                    if mapped_signals[0][corename][i][signalModified] > -1: # Not mapped to external interface
                        # Make sure we have not yet created PWIRE of this signal
                        if pwires_inserted[mapped_signals[0][corename][i][signalModified]] == False:
                            # Insert pwire
                            tester_contents.insert(find_idx(tester_contents, "PWIRES"), '    wire {} {};\n'.format(pwires[mapped_signals[0][corename][i][signalModified]][1],pwires[mapped_signals[0][corename][i][signalModified]][0]))
                            # Mark this signal as been inserted
                            pwires_inserted[mapped_signals[0][corename][i][signalModified]] = True
                        # Insert SUT PORT
                        tester_contents.insert(find_idx(tester_contents, "SUTPORTS"), '        .{}({}),\n'.format(re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal),pwires[mapped_signals[0][corename][i][signalModified]][0]))
                    else: # Mapped to external interface
                        # Insert PIO
                        tester_contents.insert(find_idx(tester_contents, "PIO"), '    {} sut_{},\n'.format(peripheral_signals[corename][signal],re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                        # Insert SUT PORT
                        tester_contents.insert(find_idx(tester_contents, "SUTPORTS"), '        .{}({}),\n'.format(re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal),"sut_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                else:
                    print("Error: signal {} of SUT.{}[{}] not mapped!".format(signal,corename,i))
                    exit(-1)
    for corename in tester_instances_amount:
        for i in range(tester_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signalModified = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                # Make sure this signal is mapped
                if mapped_signals[1][corename][i][signalModified] > -2:
                    if mapped_signals[1][corename][i][signalModified] > -1: # Not mapped to external interface
                        # Make sure we have not yet created PWIRE of this signal
                        if pwires_inserted[mapped_signals[1][corename][i][signalModified]] == False:
                            # Insert pwire
                            tester_contents.insert(find_idx(tester_contents, "PWIRES"), '    wire {} {};\n'.format(pwires[mapped_signals[1][corename][i][signalModified]][1],pwires[mapped_signals[1][corename][i][signalModified]][0]))
                            # Mark this signal as been inserted
                            pwires_inserted[mapped_signals[1][corename][i][signalModified]] = True
                    else: # Mapped to external interface
                        # Insert PIO
                        tester_contents.insert(find_idx(tester_contents, "PIO"), '    {} tester_{},\n'.format(peripheral_signals[corename][signal],re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                else:
                    print("Error: signal {} of Tester.{}[{}] not mapped!".format(signal,corename,i))
                    exit(-1)



    # Write tester.v
    tester_file = open("tester.v", "w")
    tester_file.writelines(tester_contents)
    tester_file.close()

# Create testbench for simulation with the Tester
def create_testbench(directories_str, sut_peripherals_str, tester_peripherals_str):
    # Get lists of peripherals and info about them
    sut_instances_amount = get_sut_peripherals(sut_peripherals_str)
    tester_instances_amount = get_tester_peripherals(tester_peripherals_str)
    submodule_directories = get_submodule_directories(directories_str)
    peripheral_signals = get_peripherals_signals({**sut_instances_amount, **tester_instances_amount},submodule_directories)

    # Read portmap file and get encoded data
    _, mapped_signals = read_portmap(sut_instances_amount, tester_instances_amount, peripheral_signals)

    # Read template file
    testbench_template_file = open(root_dir+"/hardware/tester/tester_core_tb.v", "r") 
    testbench_contents = testbench_template_file.readlines() 
    testbench_template_file.close()

    # Insert headers of peripherals of both systems
    for i in {**sut_instances_amount, **tester_instances_amount}:
        path = root_dir+"/"+submodule_directories[i]+"/hardware/include"
        start_index = find_idx(testbench_contents, "PHEADER")
        for file in os.listdir(path):
            if file.endswith(".vh") and not any(x in file for x in ["pio","inst","swreg"]):
                testbench_contents.insert(start_index, '`include "{}"\n'.format(path+"/"+file))
            if file.endswith("swreg.vh"):
                testbench_contents.insert(start_index, '`include "{}"\n'.format(file.replace("swreg","swreg_def")))

    # Insert PORTS and PWIRES
    for corename in sut_instances_amount:
        for i in range(sut_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signalModified = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                # Make sure this signal is mapped
                if mapped_signals[0][corename][i][signalModified] > -2:
                    if mapped_signals[0][corename][i][signalModified] == -1: # Mapped to external interface, therefore is a top_system port
                        # Insert PWIRES
                        signal_size = re.search("(?:input|output)(.+)",peripheral_signals[corename][signal]).group(1).replace(" ", "")
                        testbench_contents.insert(find_idx(testbench_contents, "PWIRES"), '    wire {} {};\n'.format(signal_size, "sut_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                        # Insert PORTS
                        testbench_contents.insert(find_idx(testbench_contents, "PORTS"), '        .{}({}),\n'.format("sut_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal), "sut_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                else:
                    print("Error: signal {} of SUT.{}[{}] not mapped!".format(signal,corename,i))
                    exit(-1)
    for corename in tester_instances_amount:
        for i in range(tester_instances_amount[corename]):
            for signal in peripheral_signals[corename]:
                signalModified = re.sub("\/\*<InstanceName>\*\/",corename,signal)
                # Make sure this signal is mapped
                if mapped_signals[1][corename][i][signalModified] > -2:
                    if mapped_signals[1][corename][i][signalModified] == -1: # Mapped to external interface, therefore is a top_system port
                        # Insert PWIRES
                        signal_size = re.search("(?:input|output)(.+)",peripheral_signals[corename][signal]).group(1).replace(" ", "")
                        testbench_contents.insert(find_idx(testbench_contents, "PWIRES"), '    wire {} {};\n'.format(signal_size, "tester_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                        # Insert PORTS
                        testbench_contents.insert(find_idx(testbench_contents, "PORTS"), '        .{}({}),\n'.format("tester_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal), "tester_"+re.sub("\/\*<InstanceName>\*\/",corename+str(i),signal)))
                else:
                    print("Error: signal {} of Tester.{}[{}] not mapped!".format(signal,corename,i))
                    exit(-1)



    # Write testbench 
    testbench_file = open("tester_tb.v", "w")
    testbench_file.writelines(testbench_contents)
    testbench_file.close()

def print_tester_nslaves(tester_peripherals_str):
    tester_instances_amount = get_tester_peripherals(tester_peripherals_str)
    i=0
    # Calculate total amount of instances
    for corename in tester_instances_amount:
        i=i+tester_instances_amount[corename]
    print(i, end="")

#Creates list of defines of sut instances with sequential numbers
def print_tester_peripheral_defines(defmacro, tester_peripherals_str):
    tester_instances_amount = get_tester_peripherals(tester_peripherals_str)
    j=0
    for corename in tester_instances_amount:
        for i in range(tester_instances_amount[corename]):
            print(defmacro+"TESTER_"+corename+str(i)+"="+str(j), end=" ")
            j = j + 1

#Replaces SUT peripheral sequential numbers with the ones from tester if they exist, otherwise, just add Tester peripheral numbers
#For example, if DEFINE list contains UART0=0 (previously defined for the SUT), and the Tester has its UART0 mapped to 1 (UART0=1), then this function replaces the UART0=0 in the list by UART0=1. If the list did not contain UART0 then it just adds UART0=1.
def replace_peripheral_defines(define_string, defmacro, tester_peripherals_str):
    define_list = define_string.split(' ')
    tester_instances_amount = get_tester_peripherals(tester_peripherals_str)
    j=0
    for corename in tester_instances_amount:
        for i in range(tester_instances_amount[corename]):
            # Check if this instance is already in the list
            foundItem = False
            for k in range(len(define_list)):
                if(define_list[k].startswith(defmacro+corename+str(i))):
                    # Was already defined in list, so replace its peripheral number
                    define_list[k] = defmacro+corename+str(i)+"="+str(j)
                    foundItem = True
                    break
            # Otherwise add it to the list
            if (foundItem == False):
                define_list.append(defmacro+corename+str(i)+"="+str(j))
            j = j + 1
    # Print complete list
    print(*define_list)

if __name__ == "__main__":
    # Parse arguments
    root_dir=sys.argv[2]
    submodule_utils.root_dir = root_dir
    if sys.argv[1] == "generate_config":
        if len(sys.argv)<6:
            print("Usage: {} generate_config <root_dir> <directories_defined_in_config.mk> <sut_peripherals> <tester_peripherals>\n".format(sys.argv[0]))
            exit(-1)
        generate_portmap(sys.argv[3], sys.argv[4], sys.argv[5])
    elif sys.argv[1] == "create_tester":
        if len(sys.argv)<6:
            print("Usage: {} create_tester <root_dir> <directories_defined_in_config.mk> <sut_peripherals> <tester_peripherals>\n".format(sys.argv[0]))
            exit(-1)
        create_tester(sys.argv[3], sys.argv[4], sys.argv[5])
    elif sys.argv[1] == "create_testbench":
        if len(sys.argv)<6:
            print("Usage: {} create_testbench <root_dir> <directories_defined_in_config.mk> <sut_peripherals> <tester_peripherals>\n".format(sys.argv[0]))
            exit(-1)
        create_testbench(sys.argv[3], sys.argv[4], sys.argv[5])
    elif sys.argv[1] == "get_n_slaves":
        if len(sys.argv)<3:
            print("Usage: {} get_n_slaves <tester_peripherals>\n".format(sys.argv[0]))
            exit(-1)
        print_tester_nslaves(sys.argv[2])
    elif sys.argv[1] == "get_defines":
        if len(sys.argv)<3:
            print("Usage: {} get_defines <tester_peripherals> <optional: defmacro>\n".format(sys.argv[0]))
            exit(-1)
        if len(sys.argv)<4:
            print_tester_peripheral_defines("",sys.argv[2])
        else:
            print_tester_peripheral_defines(sys.argv[3], sys.argv[2])
    elif sys.argv[1] == "replace_peripheral_defines":
        if len(sys.argv)<4:
            print("Usage: {} replace_peripheral_defines <DEFINE_list> <tester_peripherals> <optional: defmacro>\n".format(sys.argv[0]))
            exit(-1)
        if len(sys.argv)<5:
            replace_peripheral_defines(sys.argv[2],"",sys.argv[3])
        else:
            replace_peripheral_defines(sys.argv[2],sys.argv[4],sys.argv[3])
    else:
        print("Unknown command.\nUsage: {} <command> <parameters>\n Commands: generate_config create_tester create_testbench get_n_slaves get_defines replace_peripheral_defines".format(sys.argv[0]))
