#!/usr/bin/env python3
# It has functions to auto generate a template portmap based on peripherals list
# It's also used to read the portmap file, verify its correctness 

import sys
import re

import submodule_utils 
from submodule_utils import *

# Header to be put in portmap config file
portmap_header = """\
//********************************************************************************************************************************
// Use this file to configure port mapping between the Tester peripherals, UUT peripherals and external interface of the Tester.
// This TEMPLATE file was auto-generated by the 'make tester-config' target (portmap_utils.py)
// Port map syntax:
//    <peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : External
//    <peripheral_corename>[<peripheral_instance_number>].<peripheral_signal_name> : <other_peripheral_corename>[<other_peripheral_instance_number>].<other_peripheral_signal_name>
// Example, to connect UART instance number 0 of UUT (IOBSOC) to UART instance number 1 of Tester:
//    UART[1].UART_txd : IOBSOC[0].UART0_rxd
//    UART[1].UART_rxd : IOBSOC[0].UART0_txd
//    UART[1].UART_rts : IOBSOC[0].UART0_cts
//    UART[1].UART_cts : IOBSOC[0].UART0_rts
// Example, to connect UART instance number 0 of Tester to a dedicated external interface of the Tester: 
//    UART[0].UART_rxd : External
//    UART[0].UART_txd : External
//    UART[0].UART_cts : External
//    UART[0].UART_rts : External
//********************************************************************************************************************************
// Auto-generated list of signals to be mapped (by default mapped to external interface):
"""

# Overwrites portmap configuration file with a template, with every existing signal mapped to external interface by default
def generate_portmap(directories_str, peripherals_str, portmap_path):
    instances_amount, _ = get_peripherals(peripherals_str)
    submodule_directories = get_submodule_directories(directories_str)
    peripheral_signals = get_peripherals_signals(instances_amount,submodule_directories)

    # Generate portmap file
    portmap_file = open(portmap_path, "w")
    portmap_file.write(portmap_header)

    # Create signals for every peripheral instance
    for corename in instances_amount:
        for i in range(instances_amount[corename]):
            for signal in get_pio_signals(peripheral_signals[corename]):
                portmap_file.write("{}[{}].{} : External\n".format(corename,i,signal))
    portmap_file.close()

# Reads portmap file
# Returns:
#    pwires: List of signals that will interconnect peripherals. Each signal is an array with 2 dimensions. [0] is the signal name. [1] is the signal size.
#    mapped_signals: Dimensions=[<corename>][<instance number>][<signal name>]
#                    This list of dictionaries stores the -2 for unmapped signals, -1 for mapped to external interface 
#                    and >-1 for signals mapped to a wire in pwires list with that index.
def read_portmap(instances_amount, peripheral_signals, portmap_path):
    # Wires internal to the system that interface between peripherals
    pwires = []
    # Array to store if a signal has been mapped
    # -2 not mapped, -1 mapped to external interface, >-1 mapped to signal in pwires (index)
    mapped_signals = {} 
    for corename in instances_amount:
        mapped_signals[corename] = []
        for i in range(instances_amount[corename]):
            mapped_signals[corename].append({})
            for signal in get_pio_signals(peripheral_signals[corename]):
                mapped_signals[corename][i][signal] = -2

    # Read portmap file
    portmap_file = open(portmap_path, "r")
    portmap_contents = portmap_file.readlines() 
    portmap_file.close()

    # Parse signals, map them and create pwires signals
    for idx, i in enumerate(portmap_contents):
        i=i.replace(" ", "") # Remove all spaces
        if not i or i=="\n" or i.startswith("//"): # Ignore comments and empty lines
            continue
        result = re.search("^([^\[]+)\[(\d+)\]\.([^\:]+)\:(?:(?:External)|(?:([^\[]+)\[(\d+)\]\.(.+)))$", i)
        if result is None:
            print("Error parsing line {} of portmap file!".format(idx+1))
            exit(-1)
        try:
            # Make sure it has not been mapped before
            if not (mapped_signals[result.group(1)][int(result.group(2))][result.group(3)] < -1):
                print("Error: Portmap file line {}, Signal {} of {}[{}] already mapped previously!".format(idx+1,result.group(3),result.group(1),result.group(2)))
                exit(-1)
            if result.group(4) is None: # Mapped to external interface
                    mapped_signals[result.group(1)][int(result.group(2))][result.group(3)] = -1
            else: # Mapped to another peripheral
                # Make sure it has not been mapped before
                if not (mapped_signals[result.group(4)][int(result.group(5))][result.group(6)] < -1):
                    print("Error: Portmap file line {}, Signal {} of {}[{}] already mapped previously!".format(idx+1,result.group(6),result.group(4),result.group(5)))
                    exit(-1)
                # Make sure we are connecting an input and an output
                if ("input" in peripheral_signals[result.group(1)][result.group(3)] and "input" in peripheral_signals[result.group(4)][result.group(6)]) or\
                   ("output" in peripheral_signals[result.group(1)][result.group(3)] and "output" in peripheral_signals[result.group(4)][result.group(6)]):
                    print("Error: Portmap file line {}, can't connect because both signals are of type {}!".format(idx+1,"input" if "input" in peripheral_signals[result.group(1)][result.group(3)] else "output"))
                    exit(-1)
                signal1_size = re.search("(?:inout|input|output)(.+)",peripheral_signals[result.group(1)][result.group(3)]).group(1).replace(" ", "")
                signal2_size = re.search("(?:inout|input|output)(.+)",peripheral_signals[result.group(4)][result.group(6)]).group(1).replace(" ", "")
                # Make sure signals have the same size (give warning if we are not sure, because it may be a macro)
                if (signal1_size!=signal2_size):
                    print("Note: Portmap file line {}, signals have sizes {} and {}. These may or may not be equal!".format(idx+1,signal1_size,signal2_size))
                # Create pwires signal to merge them
                pwires.append(["merge_{}{}_{}_with_{}{}_{}".format(result.group(1),result.group(2),result.group(3),result.group(4),result.group(5),result.group(6)),signal1_size])
                # Store index of pwires signal in mapping
                mapped_signals[result.group(1)][int(result.group(2))][result.group(3)] = len(pwires)-1
                mapped_signals[result.group(4)][int(result.group(5))][result.group(6)] = len(pwires)-1
        except KeyError as e:
            print("Error: Portmap file line {}, unknown parameter {}!".format(idx+1,e))
            exit(-1)
        except IndexError as e:
            print("Error: Portmap file line {}, could not find peripheral with index given!".format(idx+1))
            exit(-1)

    #print(pwires) #DEBUG
    #print(mapped_signals) #DEBUG
    return pwires, mapped_signals

if __name__ == "__main__":
    # Parse arguments
    root_dir=sys.argv[2]
    submodule_utils.root_dir = root_dir
    if sys.argv[1] == "generate_portmap":
        if len(sys.argv)<6:
            print("Usage: {} generate_portmap <root_dir> <directories_defined_in_config.mk> <portmap_path> <peripherals>\n".format(sys.argv[0]))
            exit(-1)
        generate_portmap(sys.argv[3], sys.argv[5], sys.argv[4])
    else:
        print("Unknown command.\nUsage: {} <command> <parameters>\n Commands: generate_portmap".format(sys.argv[0]))
